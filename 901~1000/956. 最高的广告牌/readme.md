# 956. 最高的广告牌

```c++
你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。

你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。

返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。

 

示例 1：

输入：[1,2,3,6]
输出：6
解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。
示例 2：

输入：[1,2,3,4,5,6]
输出：10
解释：我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。
示例 3：

输入：[1,2]
输出：0
解释：没法安装广告牌，所以返回 0。
 

提示：

0 <= rods.length <= 20
1 <= rods[i] <= 1000
钢筋的长度总和最多为 5000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/tallest-billboard
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

---

dp[i][j] 表示前i个数任意组合，多出来的长度为 j 的最大总长度。

状态转移有三种情况，每次添加的长度加到多出来的那块上面

加到较短的那块上面

什么都不做，

分别求最大值即可。

还需要注意的一点，虽然是二维的动态规划，但是每次只与前面的一个数组有关，所以可以只用两个数组来表示。

```c++
class Solution {
public:
    int tallestBillboard(vector<int>& rods) {
        int len = rods.size();
        vector<vector<int>> dp(len+1,vector<int>(6600,0xff3f3f3f));
        dp[0][0] = 0;
        for(int i=0;i<len;i++){
            for(int j=0;j<=5000;j++){

                //什么都不做
                dp[i+1][j] = max(dp[i+1][j], dp[i][j]);
                // 加到较长的那个上面
                dp[i+1][j+rods[i]] = max(dp[i+1][j+rods[i]], dp[i][j]+rods[i]);

                //较短的
                int t = abs(j - rods[i]);
                dp[i+1][t] = max(dp[i+1][t], dp[i][j] + rods[i]);
            }
        }
        return max(0,dp[len][0]/2);
        

    }
};
```

---

