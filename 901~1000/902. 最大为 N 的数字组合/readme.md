# 902. 最大为 N 的数字组合

```c++
我们有一组排序的数字 D，它是  {'1','2','3','4','5','6','7','8','9'} 的非空子集。（请注意，'0' 不包括在内。）

现在，我们用这些数字进行组合写数字，想用多少次就用多少次。例如 D = {'1','3','5'}，我们可以写出像 '13', '551', '1351315' 这样的数字。

返回可以用 D 中的数字写出的小于或等于 N 的正整数的数目。

 

示例 1：

输入：D = ["1","3","5","7"], N = 100
输出：20
解释：
可写出的 20 个数字是：
1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.
示例 2：

输入：D = ["1","4","9"], N = 1000000000
输出：29523
解释：
我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，
81 个四位数字，243 个五位数字，729 个六位数字，
2187 个七位数字，6561 个八位数字和 19683 个九位数字。
总共，可以使用D中的数字写出 29523 个整数。
 

提示：

D 是按排序顺序的数字 '1'-'9' 的子集。
1 <= N <= 10^9

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/numbers-at-most-n-given-digit-set
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

---

位数dp，核心是将某一位的情况分为两种来考虑

第一种是改位的数为上限，执行一种操作，另一种情况是该位的数不是上限，执行另一种情况

这一道题中，`int dp[11][2] = {0};` 结尾为[0]表示不是上限，结尾为[1]表示是上限

比如N= 2345  现在我们的指针在3上面，考虑改为上的数为上限3和不是上限3的两种情况

对于是上限3，则后面的数无非是4或者其他，是上限3的结果dp[][1]就等于后面是4的情况+后面是其他情况

刚好 dp[i+1][1] = dp[i][0] + dp[i][1]

对于不是上限3，则对每一位来说，其结果就等于后面的数自由组合，该位置上每一位不是3的数，其后面的结果有pow(cnt,i);累加即可。

现在仅仅考虑了位数与N相等的情况，对于位数不为N的，必不可能比N大，，所以排列组合即可。

对于dp数组的初始化，仅做 dp[0][0] = 1; 就好、

```c++
class Solution {
public:
    int atMostNGivenDigitSet(vector<string>& D, int N) {
        int t[10] ={0};
        int cnt = D.size(); //一共有多少个数
        vector<int> T;
        int nums[11] = {0};
        int dp[11][2] = {0};
        dp[0][0] = 1;
        //dp[0][1] = 0;

        for(auto x:D) 
            T.push_back(stoi(x));
        int len = 0;
        for(int i=N; i > 0; i/=10) 
            nums[len++] = i%10;

        for(int i = 0; i<len;i++){
            for(int t:T){
                if(t == nums[i]){
                    dp[i+1][1] = dp[i][0] + dp[i][1];
                }
                else if(t < nums[i]){
                    dp[i+1][0] += pow(cnt,i);
                }
            }
        }
        int acc = 0;
        for(int i=1;i<len;i++){
            acc += pow(cnt,i);
        }
        return dp[len][0] + dp[len][1] + acc;
    }
};
```

---
