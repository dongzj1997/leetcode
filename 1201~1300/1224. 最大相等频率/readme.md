# 1224. 最大相等频率

```c++
给出一个正整数数组 nums，请你帮忙从该数组中找出能满足下面要求的 最长 前缀，并返回其长度：

从前缀中 删除一个 元素后，使得所剩下的每个数字的出现次数相同。
如果删除这个元素后没有剩余元素存在，仍可认为每个数字都具有相同的出现次数（也就是 0 次）。

 

示例 1：

输入：nums = [2,2,1,1,5,3,3,5]
输出：7
解释：对于长度为 7 的子数组 [2,2,1,1,5,3,3]，如果我们从中删去 nums[4]=5，就可以得到 [2,2,1,1,3,3]，里面每个数字都出现了两次。
示例 2：

输入：nums = [1,1,1,2,2,2,3,3,3,4,4,4,5]
输出：13
示例 3：

输入：nums = [1,1,1,2,2,2]
输出：5
示例 4：

输入：nums = [10,2,8,9,3,8,1,5,2,3,7,6]
输出：8
 

提示：

2 <= nums.length <= 10^5
1 <= nums[i] <= 10^5

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-equal-frequency
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

---

思路来源于评论区，具体看注释

```c++
class Solution {
public:
    int maxEqualFreq(vector<int>& nums) {
        int arr[50001] = {0};
        int len = nums.size();
        int ans = 0, mx =0, mxcnt = 0;
        int cnt = 0; //一共出现过几种不同的数字
        for(int i=0;i<len;i++){
            arr[nums[i]]++;
            if(arr[nums[i]] == 1) cnt++;

            if(arr[nums[i]] == mx) mxcnt++;
            else if(arr[nums[i]] > mx) {
                mxcnt = 1;
                mx = arr[nums[i]];
            }
            //分别表示，数字的最大重复值为1， 最大重复值*最大重复值出现的个数， 数字出现最大个数只有一个，需要删除一个出现最大次数的数的情况。
            //其实mx == i/cnt+1是最巧妙的，看似只限制了最后的mxcnt和mx，其实也限制了前面出现的数字都是相等的，而且出现次数一定是mx-1
            //因为如果有一个出现的次数少于mx-1的话，一定有其他数字多于或者等于mx，和前面的mxcnt == 1矛盾。所以也把前面的出现个数限制住了。
            if(mx == 1 ||  mx*mxcnt == i || (mxcnt == 1 && mx == i/cnt+1 ))
                ans = i+1;
        }
        return ans;
    }
};
```

---



